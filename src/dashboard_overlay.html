<head>
    <style> body { margin: 0; } </style>
    <script src="//cdn.jsdelivr.net/npm/force-graph"></script>
    <!--<script src="../../dist/force-graph.js"></script>-->
  </head>
  
  <body>
    <div id="graph"></div>
  
    <div id="modalOverlay" style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        z-index: 9999;
    ">
        <div style="
        position: relative;
        margin: 5% auto;
        width: 80%;
        height: 80%;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        ">
        <button onclick="closeModal()" style="
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10000;
            background: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
        ">Close</button>
        <iframe id="modalContent" src="" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
    </div>
  
    <script type="module">
      import { csvParse } from 'https://esm.sh/d3-dsv';
      import { forceCollide } from 'https://esm.sh/d3-force';
      import { GUI } from 'https://esm.sh/dat.gui';
  
      // controls
      const controls = { 'DAG Orientation': 'td' };
      const gui = new GUI();
      gui.add(controls, 'DAG Orientation', ['td', 'bu', 'lr', 'rl', 'radialout', 'radialin', null])
        .onChange(orientation => graph && graph.dagMode(orientation));
  
      // graph config
      const NODE_REL_SIZE = 1;
      const graph = new ForceGraph(document.getElementById('graph'))
        .dagMode('td')
        .dagLevelDistance(100)
        .backgroundColor('#101020')
        .linkColor(() => 'rgba(255,255,255,0.2)')
        .nodeRelSize(NODE_REL_SIZE)
        .nodeId('path')
        .nodeVal(node => 100 / (node.level + 1))
        .nodeLabel(node => node.leaf)
        .nodeAutoColorBy('module')
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.leaf;
          const fontSize = 12 / globalScale;
          ctx.font = `${fontSize}px Sans-Serif`;
          const textWidth = ctx.measureText(label).width;
          const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2); // add some padding
            
        //   ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        //   ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
        // text
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = node.color;
          ctx.fillText(label, node.x, node.y);
  
          node.__bckgDimensions = bckgDimensions;
        })
        .nodePointerAreaPaint((node, color, ctx) => {
          ctx.fillStyle = color;
          const bckgDimensions = node.__bckgDimensions;
          if (bckgDimensions) {
            ctx.fillRect(node.x - bckgDimensions[0] / 2, node.y - bckgDimensions[1] / 2, ...bckgDimensions);
          }
        })
        .linkDirectionalParticles(2)
        .linkDirectionalParticleWidth(2)
        .d3Force('collision', forceCollide(node => Math.sqrt(100 / (node.level + 1)) * NODE_REL_SIZE))
        .d3VelocityDecay(0.3)
        .d3Force('customHorizontal', alpha => {
          const nodes = graph.graphData().nodes;
          if (!nodes) return;
          const minDistance = 50;
          const maxDepth = Math.max(...nodes.map(n => n.level));
          const levels = {};
          nodes.forEach(n => {
            if (!levels[n.level]) levels[n.level] = [];
            levels[n.level].push(n);
          });
          Object.keys(levels).forEach(levelKey => {
            const level = +levelKey;
            const levelNodes = levels[level];
            if (level === maxDepth) {
              for (let i = 0; i < levelNodes.length; i++) {
                for (let j = i + 1; j < levelNodes.length; j++) {
                  const a = levelNodes[i],
                        b = levelNodes[j],
                        dx = a.x - b.x;
                  if (Math.abs(dx) < minDistance) {
                    const adjustment = (minDistance - Math.abs(dx)) * alpha * 0.5;
                    if (dx < 0) {
                      a.vx -= adjustment;
                      b.vx += adjustment;
                    } else {
                      a.vx += adjustment;
                      b.vx -= adjustment;
                    }
                  }
                }
              }
            } else {
              levelNodes.forEach(node => {
                const children = graph.childrenMap && graph.childrenMap[node.path];
                if (children && children.length) {
                  const avgX = children.reduce((sum, child) => sum + child.x, 0) / children.length;
                  node.vx += (avgX - node.x) * alpha * 2;
                }
              });
              for (let i = 0; i < levelNodes.length; i++) {
                for (let j = i + 1; j < levelNodes.length; j++) {
                  const a = levelNodes[i],
                        b = levelNodes[j],
                        dx = a.x - b.x;
                  if (Math.abs(dx) < minDistance) {
                    const adjustment = (minDistance - Math.abs(dx)) * alpha * 0.5;
                    if (dx < 0) {
                      a.vx -= adjustment;
                      b.vx += adjustment;
                    } else {
                      a.vx += adjustment;
                      b.vx -= adjustment;
                    }
                  }
                }
              }
            }
          });
        })
        .d3Force('hierarchicalAlignment', alpha => {
          const nodes = graph.graphData().nodes;
          if (!nodes) return;
          const childrenMap = graph.childrenMap;
          
          const spacingPerDepth = {
            1: 2000,
            2: 800,
            3: 400,
            4: 1000,
          };
          
          const level1Nodes = nodes.filter(n => n.level === 1);
          const modules = Array.from(new Set(level1Nodes.map(n => n.module)));
          const moduleTargets = {};
          modules.forEach((mod, i) => {
            moduleTargets[mod] = (i - (modules.length - 1) / 2) * spacingPerDepth[1];
          });
          
          function computeTargetX(node) {
            if (node.level === 1) {
              return moduleTargets[node.module] || 0;
            }
            const parentPath = node.path.substring(0, node.path.lastIndexOf('/'));
            const parentNode = nodes.find(n => n.path === parentPath);
            if (!parentNode) return 0;
            const siblings = childrenMap[parentPath] || [];
            const siblingSpacing = spacingPerDepth[node.level] || 50;
            const index = siblings.findIndex(n => n.path === node.path);
            const midIndex = (siblings.length - 1) / 2;
            return computeTargetX(parentNode) + (index - midIndex) * siblingSpacing;
          }
          
          nodes.forEach(n => {
            const targetX = computeTargetX(n);
            n.vx += (targetX - n.x) * alpha * 0.1;
          });
        });
  
      graph.onNodeClick(node => {
        graph.centerAt(node.x, node.y + 30, 1000);
        graph.zoom(4, 1000);
        
        if (!graph.childrenMap[node.path] || graph.childrenMap[node.path].length === 0) {
          openModal();
        }
      });
  
      function openModal() {
        const modal = document.getElementById("modalOverlay");
        modal.style.display = "block";
        document.getElementById("modalContent").src = "pastclass.html";
      }
  
      function closeModal() {
        document.getElementById("modalOverlay").style.display = "none";
      }
  
      fetch('treeData.csv')
        .then(r => r.text())
        .then(csvParse)
        .then(data => {
          const nodes = [], links = [];
          data.forEach(({ size, path }) => {
            const levels = path.split('/'),
                  level = levels.length - 1,
                  module = level > 0 ? levels[1] : null,
                  leaf = levels.pop(),
                  parent = levels.join('/');
            const node = { path, leaf, module, size: +size || 20, level };
            nodes.push(node);
            if (parent) {
              links.push({ source: parent, target: path });
            }
          });
          const childrenMap = {};
          nodes.forEach(n => { childrenMap[n.path] = []; });
          links.forEach(link => {
            const parentNode = nodes.find(n => n.path === link.source);
            const childNode = nodes.find(n => n.path === link.target);
            if (parentNode && childNode) {
              childrenMap[parentNode.path].push(childNode);
            }
          });
          graph.childrenMap = childrenMap;
          graph.graphData({ nodes, links });
        });
    </script>
  </body>
  